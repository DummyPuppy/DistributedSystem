Chloe Zeng
Andrew ID: zhengzen

Task0 execution

0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
0
Current size of chain: 1
Difficulty of the most recent block: 2
Total difficulty for all blocks: 2
Approximate hashes per second on this machine: 1140901
Expected total hashes required for the whole chain: 256.0
Nonce for the most recent bloc: 524
Chain hash: 00CDF6E8B8C9417856409AC6191C5A445C871F811EE6163A39C9771DAA057885
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
1
Enter difficulty >0
2
Enter transaction
Alice pays Bob 100DSCoin
Total execution time to add this block was 71 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
1
Enter difficulty >0
2
Enter transaction
Bob pays Carol 50DSCoin
Total execution time to add this block was 8 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
1
Enter difficulty >0
2
Enter transaction
Carol pays Andy 10DSCoin
Total execution time to add this block was 7 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
2
Chain verification: TRUE
Total execution time to verify the chain was 29 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
3
View the Blockchain
ds_chain :[{"index":0, "timestamp":2022-03-17 14:29:41.828277, "data":Genesis, "Previous Hash": , "nonce": 524, "difficulty": 2}
{"index":1, "timestamp":2022-03-17 14:29:47.730355, "data":Alice pays Bob 100DSCoin, "Previous Hash": 00CDF6E8B8C9417856409AC6191C5A445C871F811EE6163A39C9771DAA057885, "nonce": 571, "difficulty": 2}
{"index":2, "timestamp":2022-03-17 14:29:55.962218, "data":Bob pays Carol 50DSCoin, "Previous Hash": 00432A4A816B8B71058E18772D046F17473406110D7794008E39C079985704DE, "nonce": 15, "difficulty": 2}
{"index":3, "timestamp":2022-03-17 14:30:10.732402, "data":Carol pays Andy 10DSCoin, "Previous Hash": 002DAC2669CF63F2C893E6351959CE66F9F94F2D1C3D9D6150479271BF7B2989, "nonce": 27, "difficulty": 2}
], chainHash: 007BBD2CF1E35CAA5D989E26CDD08D1FB8D40ECE4EB652A66D8102921B84184C}
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
4
Enter block ID of block to corrupt
1
Enter new data for block 1
Alice pays Bob 76 DSCoin
Block 1 now holds Alice pays Bob 76 DSCoin
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
3
View the Blockchain
ds_chain :[{"index":0, "timestamp":2022-03-17 14:29:41.828277, "data":Genesis, "Previous Hash": , "nonce": 524, "difficulty": 2}
{"index":1, "timestamp":2022-03-17 14:29:47.730355, "data":Alice pays Bob 76 DSCoin, "Previous Hash": 00CDF6E8B8C9417856409AC6191C5A445C871F811EE6163A39C9771DAA057885, "nonce": 571, "difficulty": 2}
{"index":2, "timestamp":2022-03-17 14:29:55.962218, "data":Bob pays Carol 50DSCoin, "Previous Hash": 00432A4A816B8B71058E18772D046F17473406110D7794008E39C079985704DE, "nonce": 15, "difficulty": 2}
{"index":3, "timestamp":2022-03-17 14:30:10.732402, "data":Carol pays Andy 10DSCoin, "Previous Hash": 002DAC2669CF63F2C893E6351959CE66F9F94F2D1C3D9D6150479271BF7B2989, "nonce": 27, "difficulty": 2}
], chainHash: 007BBD2CF1E35CAA5D989E26CDD08D1FB8D40ECE4EB652A66D8102921B84184C}
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
2
Node 2 does not have the right previous hash 
Chain verification: FALSE
Total execution time to verify the chain was 24 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
5
Total execution time required to repair the chain was -17.0 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
2
Chain verification: TRUE
Total execution time to verify the chain was 29 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
1
Enter difficulty >0
4
Enter transaction
Andy pays Sean 25 DSCoin
Total execution time to add this block was 79 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
0
Current size of chain: 5
Difficulty of the most recent block: 4
Total difficulty for all blocks: 12
Approximate hashes per second on this machine: 0.0
Expected total hashes required for the whole chain: 66560.0
Nonce for the most recent bloc: 6981
Chain hash: 0000493D2BF4B19CBFFC0C55D617BDD2D0871FD78A0D218FAAEDE93F40FECA0F
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
6

Process finished with exit code 0

================================
Task 0 Block.java

/** Email: zhengzen@andrew.cmu.edu
 * Author: Zheng Zeng */
import java.math.BigInteger;
import java.security.MessageDigest;
import java.sql.Timestamp;
import java.util.ArrayList;

public class Block {
  // initiate all instance variables
  private int indx;
  private Timestamp tstamp;
  private String data;
  private int diff;
  private BigInteger nonce;
  private MessageDigest md;
  private String previousHash = "";

  // constructor of Block
  // set the values of Block

  public Block(int index, java.sql.Timestamp timestamp, java.lang.String data, int difficulty) {
    this.indx = index;
    this.tstamp = timestamp;
    this.data = data;
    this.diff = difficulty;
    this.nonce = BigInteger.ZERO;
  }

  /** setters and getters of the Block */
  public void setData(String data) {
    this.data = data;
  }

  public void setTstamp(Timestamp tstamp) {
    this.tstamp = tstamp;
  }

  public void setIndx(int indx) {
    this.indx = indx;
  }

  public void setDiff(int diff) {
    this.diff = diff;
  }

  public void setPreviousHash(String previousHash) {
    this.previousHash = previousHash;
  }

  public String getData() {
    return data;
  }

  public int getDiff() {
    return diff;
  }

  public int getIndx() {
    return indx;
  }

  public Timestamp getTstamp() {
    return tstamp;
  }

  public String getPreviousHash() {
    return previousHash;
  }

  public BigInteger getNonce() {
    return this.nonce;
  }

  /** proofOfWork: to acquire the correct hash according to the difficulty */
  public String proofOfWork() {
    // initiate the nonce to be zero
    nonce = BigInteger.ZERO;
    // build the message to be hashed
    String message = indx + tstamp.toString() + data + getPreviousHash() + nonce + diff;
    // using the calculateHash(message) method to compute a hash
    String hash = calculateHash(message);
    // construct the required prefix string
    String difficulty = "0".repeat(diff);
    //        System.out.println("difficutly is "+ difficulty);
    // while the hash does not begin with the current prefix
    while (!hash.startsWith(difficulty)) {
      nonce = nonce.add(BigInteger.ONE); // add one to nonce
      //            System.out.println(nonce.toString());
      // re-build the message with the new nonce
      message = indx + tstamp.toString() + data + getPreviousHash() + nonce + diff;
      hash = calculateHash(message);
      //            System.out.println(hash);
    }
    return hash; // get the proofOfWork
  }

  /**
   * calculateHash: take a message and compute its hash of SHA-256
   *
   * @param message
   * @return
   */
  public String calculateHash(String message) {
    try {
      md = MessageDigest.getInstance("SHA-256");
      md.update(message.getBytes());
      // get SHA-256 hexstring
      String hash = bytesToHex(md.digest());
      return hash;
    } catch (Exception e) {
      e.getStackTrace();
      return null;
    }
  }

  /** bytesToHex: turn the md.digest() into string representation from lab and project1 codes */
  private static final char[] hex_arr = "0123456789ABCDEF".toCharArray();

  public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j < bytes.length; j++) {
      int v = bytes[j] & 0xFF;
      hexChars[j * 2] = hex_arr[v >>> 4];
      hexChars[j * 2 + 1] = hex_arr[v & 0x0F];
    }
    return new String(hexChars);
  }

  /**
   * toString: print out the content of the Block in a json format
   *
   * @return
   */
  @Override
  public String toString() {
    return "{"
        + "\"index\":"
        + indx
        + ", \"timestamp\":"
        + tstamp
        + ", \"data\":"
        + data
        + ", \"Previous Hash\": "
        + previousHash
        + ", \"nonce\": "
        + nonce
        + ", \"difficulty\": "
        + diff
        + '}';
  }
}

===========================
 Task 0 BlockChain.java
 /** Email: zhengzen@andrew.cmu.edu
 * Author: Zheng Zeng */
import javax.management.timer.TimerMBean;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Scanner;

public class BlockChain {
  // contains an array of blocks
  ArrayList<Block> block_list;
  // a chain hash of the most recently added block
  String chainHash = "";
  double hashesPerSecond;
  // constructor
  // at initiation, it builds an arraylist and compute hashes per second
  public BlockChain() throws NoSuchAlgorithmException {
    block_list = new ArrayList<Block>();
  }

  /**
   * isChainValid: to see if the chain is valid, the logic is : If the chain only contains one
   * block, the genesis block at position 0, this routine computes the hash of the block and checks
   * that the hash has the requisite number of leftmost 0's (proof of work) as specified in the
   * difficulty field.
   *
   * <p>It also checks that the chain hash is equal to this computed hash. If either check fails,
   * return an error message. Otherwise, return the string "TRUE". If the chain has more blocks than
   * one, begin checking from block one. Continue checking until you have validated the entire
   * chain. The first check will involve a computation of a hash in Block 0 and a comparison with
   * the hash pointer in Block 1. If they match and if the proof of work is correct, go and visit
   * the next block in the chain. At the end, check that the chain hash is also correct.
   *
   * @return
   */
  public String isChainValid() {
    try {
      Block cur = null; // initiate a cursor
      String prevHash = ""; // initiate the previous hash
      String diff; // initiate the difficulty level
      // when the block only contains 1 block
      if (block_list.size() == 1) {
        cur = block_list.get(0);
        diff = "0".repeat(cur.getDiff());
        // see if it has the correct first 0s.
        if (cur.proofOfWork().startsWith(diff)) {
          // continue to see if chain hash is this proofOfWork

        }
      } else {
        // when there are more than 1 block
        for (int j = 0; j < block_list.size(); j++) {
          // use the first block and compute its hash
          // the hash of the previous node, beginning with block 0
          cur = block_list.get(j); // start with block 0
          // compare its requisite number of 0's
          diff = "0".repeat(cur.getDiff());
          if (cur.getPreviousHash()
              .equals(
                  prevHash)) { // if the previous hash is aligned with the previous node's
                               // proofOfWork
            if (cur.proofOfWork()
                .startsWith(diff)) { // if the current block contains the correct hash
              // all good, keep looping
            } else {
              // print out the problem
              System.out.printf("Improper hash on node %d Does not begin with %s", j, diff);
              return "FALSE";
            }
          } else {
            // print out the problem
            System.out.printf("Node %d does not have the right previous hash \n", j);
            return "FALSE";
          }
          prevHash =
              cur.proofOfWork(); // assign the proofOfWork of current block to be the previous hash
        }
      }
      // check if the chainhash is correct after checking each block's proofOfWork and its previous
      // hash
      if (chainHash.equals(getLatestBlock().proofOfWork())) {
        return "TRUE";
      } else {
        System.out.println("Chain hash is not correct.");
        return "FALSE";
      }
    } catch (Exception e) {
      e.getStackTrace();
      return "FALSE";
    }
  }
  // repair the chain if the hashes are not consistent
  public void repairChain() {
    Block curr; // initiate a cursor
    String pre_hash = ""; // the default previous hash
    for (int j = 0; j < block_list.size(); j++) {
      curr = getBlock(j);
      curr.setPreviousHash(pre_hash); // correct its previous hash
      pre_hash = curr.proofOfWork(); // assign the current block's hash to be the previous hash for the next block
    }
      this.chainHash = pre_hash;// assign the current block's hash to be the chain hash
  }
  // add block method: 1. set the new block's previous block's hash; 2. add the new block to the end
  // of the list;
  // 3. add the new hash to chain hash
  public void addBlock(Block newBlock) {
    newBlock.setPreviousHash(chainHash);
    block_list.add(newBlock);
    this.chainHash = getLatestBlock().proofOfWork();
  }
  // computeHashesPerSecond: measure the time it takes to compute 2,000,000 hashes and assign the
  // hashesPerSecond variable.
  public void computeHashesPerSecond() throws NoSuchAlgorithmException {
    long start = System.currentTimeMillis();
    for (int i = 0; i < 2000000; i++) {
      MessageDigest md = MessageDigest.getInstance("SHA-256");
      md.update("00000000".getBytes());
      // get SHA-256 hexstring
      bytesToHex(md.digest());
    }
    long end = System.currentTimeMillis();
    hashesPerSecond = (2000000 / ((start - end) / 1000.0));
  }
  /** bytesToHex: turn the md.digest() into string representation from lab and project1 codes */
  private static final char[] hex_arr = "0123456789ABCDEF".toCharArray();

  public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j < bytes.length; j++) {
      int v = bytes[j] & 0xFF;
      hexChars[j * 2] = hex_arr[v >>> 4];
      hexChars[j * 2 + 1] = hex_arr[v & 0x0F];
    }
    return new String(hexChars);
  }

  /**
   * getters
   *
   * @param i
   * @return
   */
  public Block getBlock(int i) {
    return block_list.get(i);
  }

  public String getChainHash() {
    return chainHash;
  }

  public int getChainSize() {
    return block_list.size();
  }

  // to get hashes per second
  public double getHashesPerSecond() throws NoSuchAlgorithmException {
    return hashesPerSecond;
  }

  // get the latest block
  public Block getLatestBlock() {
    return block_list.get(block_list.size() - 1);
  }
  // get the total expected hashes length for the list
  public double getTotalExpectedHashes() {
    double totalExpectedHashes = 0.0;
    for (int i = 0; i < getChainSize(); i++) {
      // for each block, the expected hash is 16 to the power of its difficulty.
      totalExpectedHashes += Math.pow(16.0, getBlock(i).getDiff());
    }
    return totalExpectedHashes;
  }
  // get the total difficulty level of the whole block chain
  public int getTotalDifficulty() {
    int totalDiff = 0;
    for (int j = 0; j < block_list.size(); j++) {
      totalDiff += block_list.get(j).getDiff();
    }
    return totalDiff;
  }

  // get the current system time

  public Timestamp getTime() {
    return java.sql.Timestamp.valueOf(LocalDateTime.now());
  }
  // print the information about the chain
  // using the toString method from the block class
  public void printChain() {
    System.out.printf("ds_chain :[");
    for (int i = 0; i < block_list.size(); i++) {
      System.out.println(block_list.get(i));
    }

    System.out.println("], chainHash: " + getChainHash() + "}");
  }

  public void viewBasicStatus() throws NoSuchAlgorithmException {
    System.out.println("Current size of chain: " + getChainSize());
    System.out.println(
        "Difficulty of the most recent block: " + getLatestBlock().getDiff());
    System.out.println("Total difficulty for all blocks: " + getTotalDifficulty());
    System.out.println("Approximate hashes per second on this machine: " + getHashesPerSecond());
    System.out.println(
        "Expected total hashes required for the whole chain: " + getTotalExpectedHashes());
    System.out.println(
        "Nonce for the most recent bloc: " + getLatestBlock().getNonce());
    System.out.println("Chain hash: " + getChainHash());
  }

  /**
   * The main driver of building the blocks and executions.
   *
   * @param args
   * @throws NoSuchAlgorithmException
   */
  public static void main(String[] args) throws NoSuchAlgorithmException {
    BlockChain chain = new BlockChain();
    // add the initial block Genesis
    Block initial = new Block(0, chain.getTime(), "Genesis", 2);
    chain.addBlock(initial);
    try {
      // print out the menu
      System.out.println(
          ""
              + "0. View basic blockchain status.\n"
              + "1. Add a transaction to the blockchain.\n"
              + "2. Verify the blockchain.\n"
              + "3. View the blockchain.\n"
              + "4. corrupt the chain.\n"
              + "5. Hide the corruption by repairing the chain.\n"
              + "6. Exit");
      // read in any input
      Scanner sc = new Scanner(System.in);
      int instruction = sc.nextInt();
      while (instruction < 6) { // while instruction is correct
        switch (instruction) {
          case 0:
            {
              chain.viewBasicStatus();
              break;
            }
          case 1:
            {
              // add a new block, initiate one
              Block newblock = new Block(chain.getChainSize(), chain.getTime(), null, 0);
              System.out.println("Enter difficulty >0");
              newblock.setDiff(sc.nextInt()); // set the difficulty level
              System.out.println("Enter transaction");
              sc.nextLine(); // jump over the current line
              newblock.setData(sc.nextLine()); // set the data
              Long start = System.currentTimeMillis(); // start counting the milliseconds
              chain.addBlock(newblock);
              Long end = System.currentTimeMillis();
              int duration = (int) (end - start);
              // return the time used for adding the block
              System.out.println(
                  "Total execution time to add this block was "
                      + duration
                      + " milliseconds"); // execution time
              break;
            }
          case 2:
            {
              // start counting the time
              long start = System.currentTimeMillis();
              // return the chain's validity
              System.out.println("Chain verification: " + chain.isChainValid());
              long end = System.currentTimeMillis();
              int duration = (int) (end - start);
              // return the time used for checking validity
              System.out.println(
                  "Total execution time to verify the chain was " + duration + " milliseconds");
              break;
            }
          case 3:
            {
              System.out.println("View the Blockchain");
              chain.printChain(); // print out each block and the chain data in a json format
              break;
            }
          case 4:
            {
              // corrupt a block by changing its value
              System.out.println("Enter block ID of block to corrupt");
              int s = sc.nextInt(); // get the id of the block
              System.out.println("Enter new data for block " + s);
              sc.nextLine(); // jump over the current line
              String newdata = sc.nextLine(); // acquire the new data
              chain.block_list.get(s).setData(newdata); // set the new data to block s
              System.out.println("Block " + s + " now holds " + newdata);
              break;
            }
          case 5:
            {
              // repair the chain
              Long start = System.currentTimeMillis();
              chain.repairChain();
              Long end = System.currentTimeMillis();
              double duration = (end - start);
              System.out.println(
                  "Total execution time required to repair the chain was "
                      + duration
                      + " milliseconds"); // repair time
            }
        }
        // print the menu again
        System.out.println(
            ""
                + "0. View basic blockchain status.\n"
                + "1. Add a transaction to the blockchain.\n"
                + "2. Verify the blockchain.\n"
                + "3. View the blockchain.\n"
                + "4. corrupt the chain.\n"
                + "5. Hide the corruption by repairing the chain.\n"
                + "6. Exit");
        instruction = sc.nextInt();
      }
    } catch (NoSuchAlgorithmException e) {
      e.getMessage();
    }
  }
}
============Task 0 END==================

Task 1 Client side execution

Client starts running
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
0
View chain status
Response: {"selection":0,"size":1,"chainHash":0083A02C6491E4F1063B2B43BCDB2BA916303A7D28AF4F2B0F7DCB5CBA615939,"totalHashes":256.0,"totalDiff":2,"recentNonce":151,"diff":2,"hps":1328021}
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
1
Enter difficulty >0
2
Enter transaction
Alice pays Bob 100DSCoin
"Total execution time to add this block was 33 milliseconds"
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
1
Enter difficulty >0
2
Enter transaction
Bob pays Carol 50 DSCoin
"Total execution time to add this block was 12 milliseconds"
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
1
Enter difficulty >0
2
Enter transaction
Carol pays Andy 10 DSCoin
"Total execution time to add this block was 31 milliseconds"
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
2
Verify the chain
Chain verification: TRUE
Total execution time to validate the block chain was 35 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
3
View the Blockchain
{ds_chain :[{"index":0, "timestamp":2022-03-19 00:11:52.328447, "data":Genesis, "Previous Hash": , "nonce": 151, "difficulty": 2},
{"index":1, "timestamp":2022-03-19 00:12:06.337107, "data":Alice pays Bob 100DSCoin, "Previous Hash": 0083A02C6491E4F1063B2B43BCDB2BA916303A7D28AF4F2B0F7DCB5CBA615939, "nonce": 315, "difficulty": 2},
{"index":2, "timestamp":2022-03-19 00:12:15.777673, "data":Bob pays Carol 50 DSCoin, "Previous Hash": 0070D9EFD8FF3E7D6800223F68F0D3533F214D0141B5469B91643ACB1C94C430, "nonce": 169, "difficulty": 2},
{"index":3, "timestamp":2022-03-19 00:12:24.467466, "data":Carol pays Andy 10 DSCoin, "Previous Hash": 006479D9E70665C4C68DA9537383D516E429D60568DF3C3E17514B321366FCFA, "nonce": 388, "difficulty": 2}], chainHash: 00764156F45068621618B75D58E2E83C43361D21287D6892D96B3B06D59ED44E}
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
4
Enter block ID of block to corrupt
1
Enter new data for block 1
Alice pays Bob 76 DSCoin
Block 1 now holds data Alice pays Bob 76 DSCoin
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
3
View the Blockchain
{ds_chain :[{"index":0, "timestamp":2022-03-19 00:11:52.328447, "data":Genesis, "Previous Hash": , "nonce": 151, "difficulty": 2},
{"index":1, "timestamp":2022-03-19 00:12:06.337107, "data":Alice pays Bob 76 DSCoin, "Previous Hash": 0083A02C6491E4F1063B2B43BCDB2BA916303A7D28AF4F2B0F7DCB5CBA615939, "nonce": 315, "difficulty": 2},
{"index":2, "timestamp":2022-03-19 00:12:15.777673, "data":Bob pays Carol 50 DSCoin, "Previous Hash": 0070D9EFD8FF3E7D6800223F68F0D3533F214D0141B5469B91643ACB1C94C430, "nonce": 169, "difficulty": 2},
{"index":3, "timestamp":2022-03-19 00:12:24.467466, "data":Carol pays Andy 10 DSCoin, "Previous Hash": 006479D9E70665C4C68DA9537383D516E429D60568DF3C3E17514B321366FCFA, "nonce": 388, "difficulty": 2}], chainHash: 00764156F45068621618B75D58E2E83C43361D21287D6892D96B3B06D59ED44E}
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
2
Verify the chain
Chain verification: FALSE
Node 2 does not have the right previous hash 

Total execution time to validate the block chain was 3 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
5
Repair the chain
Total execution time to repair the chain was 14 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
2
Verify the chain
Chain verification: TRUE
Total execution time to validate the block chain was 10 milliseconds
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
1
Enter difficulty >0
4
Enter transaction
Andy pays Sean 25 DSCoin
"Total execution time to add this block was 285 milliseconds"
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
0
View chain status
Response: {"selection":0,"size":5,"chainHash":00006CA3574A8F60F388B93E3EEA3044DC6041A7080D8AB8D8EA4E515B97333B,"totalHashes":66560.0,"totalDiff":12,"recentNonce":79719,"diff":4,"hps":1324503}
0. View basic blockchain status.
1. Add a transaction to the blockchain.
2. Verify the blockchain.
3. View the blockchain.
4. corrupt the chain.
5. Hide the corruption by repairing the chain.
6. Exit
6

Process finished with exit code 0

===============================
Task 1 Server Side Execution 

server started
We have a visitor
Current size of chain: 1
Difficulty of the most recent block: 2
Total difficulty for all blocks: 2
Approximate hashes per second on this machine: 1157407.4074074074
Expected total hashes required for the whole chain: 256.0
Nonce for the most recent bloc: 151
Chain hash: 0083A02C6491E4F1063B2B43BCDB2BA916303A7D28AF4F2B0F7DCB5CBA615939
Response: {"selection":0,"size":1,"chainHash":0083A02C6491E4F1063B2B43BCDB2BA916303A7D28AF4F2B0F7DCB5CBA615939,"totalHashes":256.0,"totalDiff":2,"recentNonce":151,"diff":2,"hps":1328021}
Adding a block
Setting response to Total execution time to add this block was 33 milliseconds
"Total execution time to add this block was 33 milliseconds"
Adding a block
Setting response to Total execution time to add this block was 12 milliseconds
"Total execution time to add this block was 12 milliseconds"
Adding a block
Setting response to Total execution time to add this block was 31 milliseconds
"Total execution time to add this block was 31 milliseconds"
Verifying entire chain
Chain verification: TRUE
Setting response to Total execution time to validate the block chain was 35 milliseconds
Chain verification: TRUE
Total execution time to validate the block chain was 35 milliseconds
View the blockchain
{ds_chain :[{"index":0, "timestamp":2022-03-19 00:11:52.328447, "data":Genesis, "Previous Hash": , "nonce": 151, "difficulty": 2},
{"index":1, "timestamp":2022-03-19 00:12:06.337107, "data":Alice pays Bob 100DSCoin, "Previous Hash": 0083A02C6491E4F1063B2B43BCDB2BA916303A7D28AF4F2B0F7DCB5CBA615939, "nonce": 315, "difficulty": 2},
{"index":2, "timestamp":2022-03-19 00:12:15.777673, "data":Bob pays Carol 50 DSCoin, "Previous Hash": 0070D9EFD8FF3E7D6800223F68F0D3533F214D0141B5469B91643ACB1C94C430, "nonce": 169, "difficulty": 2},
{"index":3, "timestamp":2022-03-19 00:12:24.467466, "data":Carol pays Andy 10 DSCoin, "Previous Hash": 006479D9E70665C4C68DA9537383D516E429D60568DF3C3E17514B321366FCFA, "nonce": 388, "difficulty": 2}], chainHash: 00764156F45068621618B75D58E2E83C43361D21287D6892D96B3B06D59ED44E}
corrupt the Blockchain
Block 1 now holds data Alice pays Bob 76 DSCoin
Block 1 now holds data Alice pays Bob 76 DSCoin
View the blockchain
{ds_chain :[{"index":0, "timestamp":2022-03-19 00:11:52.328447, "data":Genesis, "Previous Hash": , "nonce": 151, "difficulty": 2},
{"index":1, "timestamp":2022-03-19 00:12:06.337107, "data":Alice pays Bob 76 DSCoin, "Previous Hash": 0083A02C6491E4F1063B2B43BCDB2BA916303A7D28AF4F2B0F7DCB5CBA615939, "nonce": 315, "difficulty": 2},
{"index":2, "timestamp":2022-03-19 00:12:15.777673, "data":Bob pays Carol 50 DSCoin, "Previous Hash": 0070D9EFD8FF3E7D6800223F68F0D3533F214D0141B5469B91643ACB1C94C430, "nonce": 169, "difficulty": 2},
{"index":3, "timestamp":2022-03-19 00:12:24.467466, "data":Carol pays Andy 10 DSCoin, "Previous Hash": 006479D9E70665C4C68DA9537383D516E429D60568DF3C3E17514B321366FCFA, "nonce": 388, "difficulty": 2}], chainHash: 00764156F45068621618B75D58E2E83C43361D21287D6892D96B3B06D59ED44E}
Verifying entire chain
Node 2 does not have the right previous hash 
Chain verification: FALSE
Node 2 does not have the right previous hash 

Setting response to Total execution time to validate the block chain was 3 milliseconds
Chain verification: FALSE
Node 2 does not have the right previous hash 

Total execution time to validate the block chain was 3 milliseconds
Repairing the entire chain
Setting respouse to Total execution time to repair the chain was 14 milliseconds
Total execution time to repair the chain was 14 milliseconds
Verifying entire chain
Chain verification: TRUE
Setting response to Total execution time to validate the block chain was 10 milliseconds
Chain verification: TRUE
Total execution time to validate the block chain was 10 milliseconds
Adding a block
Setting response to Total execution time to add this block was 285 milliseconds
"Total execution time to add this block was 285 milliseconds"
We have a visitor
Current size of chain: 5
Difficulty of the most recent block: 4
Total difficulty for all blocks: 12
Approximate hashes per second on this machine: 1308044.4735120996
Expected total hashes required for the whole chain: 66560.0
Nonce for the most recent bloc: 79719
Chain hash: 00006CA3574A8F60F388B93E3EEA3044DC6041A7080D8AB8D8EA4E515B97333B
Response: {"selection":0,"size":5,"chainHash":00006CA3574A8F60F388B93E3EEA3044DC6041A7080D8AB8D8EA4E515B97333B,"totalHashes":66560.0,"totalDiff":12,"recentNonce":79719,"diff":4,"hps":1324503}

==================
Task 1 Client Source Code


/**
 * Email: zhengzen@andrew.cmu.edu
 * Author: Zheng Zeng
 **/

import com.google.gson.Gson;

import java.io.*;
import java.net.Socket;
import java.util.Scanner;

public class BlockClientTCP {
    //the client TCP's instance variables
    Gson gson; //to translate json into Objects and Objects into json
    requestMessage request; //to store the request sent to the server
    responseMessage response; //to store the response from the server
    Socket clientSocket; //the socket initiator

    //constructor
    public BlockClientTCP(){
        //initiate instance variables
        gson = new Gson();
        request= new requestMessage();
        response = new responseMessage();
    }

    /**
     * runClient: the method to call other methods in this class
     * used in main method
     */
    public void runClient(){
    // run the client side
    System.out.println("Client starts running");
        // print out the menu
        System.out.println(
                ""
                        + "0. View basic blockchain status.\n"
                        + "1. Add a transaction to the blockchain.\n"
                        + "2. Verify the blockchain.\n"
                        + "3. View the blockchain.\n"
                        + "4. corrupt the chain.\n"
                        + "5. Hide the corruption by repairing the chain.\n"
                        + "6. Exit");
        // read in instruction integer
        Scanner sc = new Scanner(System.in);
        int instruction = sc.nextInt();
        while (instruction < 6) { // while instruction is correct
            //set the instruction of the request
            request.setSelection(instruction);
            switch (instruction) {
                //based on different instructions, provide different services and set corresponding variables in the request.
                case 0:
                {
            System.out.println("View chain status");
                    break;
                }
                case 1:
                {
                    // ask for the difficulty
                    System.out.println("Enter difficulty >0");
                   request.setDiff(sc.nextInt()); // set the difficulty level
                    // ask for the transaction data
                    System.out.println("Enter transaction");
                    sc.nextLine(); // jump over the current line
                    request.setTransaction(sc.nextLine());// set the data of the request
                    break;
                }
                case 2:
                {
            // verify the chain
            System.out.println("Verify the chain");
                    break;
                }
                case 3:
                {
                    //view the detail of the chain
                    System.out.println("View the Blockchain");
                    break;
                }
                case 4:
                {
                    // corrupt a block by changing its value
                    System.out.println("Enter block ID of block to corrupt");
                    int s = sc.nextInt(); // get the id of the block
                    request.setCorruptId(s);
                    System.out.println("Enter new data for block " + s);
                    sc.nextLine(); // jump over the current line
                    String newdata = sc.nextLine(); // acquire the new data
                    request.setTransaction(newdata); // set the new data to block s
                    break;
                }
                case 5:
                {
                    //repair the chain
            System.out.println("Repair the chain");
                    break;
                }
            }
            // send other the request and get for the response
            response = sendRequest(request);
            //use the response's method to show its values;
            response.viewResult();
            System.out.println(
                    ""
                            + "0. View basic blockchain status.\n"
                            + "1. Add a transaction to the blockchain.\n"
                            + "2. Verify the blockchain.\n"
                            + "3. View the blockchain.\n"
                            + "4. corrupt the chain.\n"
                            + "5. Hide the corruption by repairing the chain.\n"
                            + "6. Exit");
            instruction = sc.nextInt();
        }
    }
    public responseMessage sendRequest(requestMessage req){
        //initiate the socket
        clientSocket = null;
        try {
            int serverPort = 6789;
            clientSocket = new Socket("localhost", serverPort);
            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream())));
            //while request is not null, send the request
            if (req != null) {
                //turn the request into a json String
                String jsonRequest = gson.toJson(req);
                out.println(jsonRequest); //send the json String to the server
                out.flush();
                String responseString= in.readLine(); // retrieve the response string from the server
                response = gson.fromJson(responseString,responseMessage.class);//turn the response string into responseMessage object
            }

        } catch (IOException e) {
            System.out.println("IO Exception:" + e.getMessage());
        } finally {
            try {
                if (clientSocket != null) {
                    clientSocket.close();
                }
            } catch (IOException e) {
                // ignore exception on close
            }
        }
        return response; //send the result to the loop
    }


  public static void main(String[] args) {
    //run the client
      BlockClientTCP client = new BlockClientTCP();
      client.runClient();

  }
}


=====================
Task 1 Server Source Code
/**
 * Email: zhengzen@andrew.cmu.edu
 * Author: Zheng Zeng
 **/

import com.google.gson.Gson;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.NoSuchAlgorithmException;
import java.util.Scanner;


/**
 * includes some instance variables
 */
public class BlockServerTCP {
    //it has a block chain object to store all blocks
    BlockChain chain;
    //it has a response object to write out response
    responseMessage response;
    //it has a gson object to translate json into and from objects.
    Gson gson;

    public BlockServerTCP() throws NoSuchAlgorithmException {
        chain = new BlockChain();
        response = new responseMessage();
        gson = new Gson();
    }

    /**
     * this is the method used in the main method to get everything running.
     */
    public void run(){
        //initiate the socket to listen for client's requests.
        Socket clientSocket = null;
        try {
            System.out.println("server started");
            int serverPort = 6789; // the server port we are using

            // Create a new server socket
            ServerSocket listenSocket = new ServerSocket(serverPort);

            /*
             * Block waiting for a new connection request from a client.
             * When the request is received, "accept" it, and the rest
             * the tcp protocol handshake will then take place, making
             * the socket ready for reading and writing.
             */
            // If we get here, then we are now connected to a client.
            clientSocket = listenSocket.accept();
            // Set up "in" to read from the client socket
            Scanner in;


            // Set up "out" to write to the client socket
            PrintWriter out;


            /**
             * read in the request, handle the request and then write the response to the client.
             */
            while (true) {
                in = new Scanner(clientSocket.getInputStream());
                out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream())));
                while (in.hasNext()) {
                    String data = in.nextLine();
                    responseMessage response = handleRequest(data);
                    String jsonResponse = gson.toJson(response);
                    out.println(jsonResponse);
                    out.flush();
                }
                in.close();
                out.close();
                clientSocket = listenSocket.accept();

            }

            // Handle exceptions
        } catch (IOException  e) {
            System.out.println("IO Exception:" + e.getMessage());

            // If quitting (typically by you sending quit signal) clean up sockets
        }catch ( NoSuchAlgorithmException e){
            e.getStackTrace();
            e.getMessage();
        }
        finally {
            try {
                System.out.println("server side quitting.");
                if (clientSocket != null) {
                    clientSocket.close();
                }
            } catch (IOException e) {
                // ignore exception on close
            }
        }
    }

    /**
     * the core method to deal with different requests and manipulate the response object.
     * @param request
     * @return
     * @throws NoSuchAlgorithmException
     */
    public responseMessage handleRequest(String request) throws NoSuchAlgorithmException {
        //when the chain has 0 block, initiate a block for the chain.
        if (chain.getChainSize() == 0) {
            // create a genesis Block
            Block genesisBlock = new Block(0, chain.getTime(), "Genesis", 2);
            chain.addBlock(genesisBlock);
        }
        //parse the request
        requestMessage req = gson.fromJson(request,requestMessage.class);
        int instruction = req.getSelection(); //get the instruction from the request
        response.setSelection(instruction); //set the instruction in the response Object
        //now properly deal with each type of request.
        switch (instruction){
            case 0:
            {
          System.out.println("We have a visitor");
          response.setChainStatus(chain);
                break;
            }
            case 1:{
                response.addNewBlock(chain,req.getDiff(),req.getTransaction());
                break;
            }
            case 2:{
          System.out.println("Verifying entire chain");
          response.verifyChain(chain);
          break;
            }
            case 3:{
          System.out.println("View the blockchain");
          response.setChainDetail(chain.printChain());
                break;
            }
            case 4:
            {
          System.out.println("corrupt the Blockchain");
          response.corruptBlockchain(chain, req.getCorruptId(), req.getTransaction());
          break;
            }
            case 5:{
          System.out.println("Repairing the entire chain");
          response.repairChain(chain);
          break;
            }
        }
        //view the result of the request
        response.viewResult();
        //return it for the run() method to send it to the client
        return response;
}

    /**
     * the main method to run and generate everything on the console
     * @param args
     * @throws NoSuchAlgorithmException
     */
    public static void main(String[] args) throws NoSuchAlgorithmException {
        BlockServerTCP server = new BlockServerTCP();
        server.run();

  }
}
